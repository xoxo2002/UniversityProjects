import java.util.concurrent.*;
import java.io.*;
import java.util.*;

// Branch class that contains BranchID and salesRecord(total units sold for each product)
// Consist of a function that calculates the total profits generated by this branch
// Read-only
class Branch {
    String branchID;
    HashMap<Product, Integer> salesRecord;
    Double totalDailyProfit = 0.0;

    // constructor and getter
    public Branch(String branchID,  HashMap<Product, Integer> salesRecord) {
        this.branchID = branchID;
        this.salesRecord = salesRecord;
    }
    public String getBranchID() {
        return branchID;
    }
    public HashMap<Product, Integer> getSalesRecord(){
        return salesRecord;
    }

    // generates total profit generated from all products
    public Double getDailyTotalProfit(){
        for (HashMap.Entry<Product, Integer> entry : this.salesRecord.entrySet()) {
            Double productProfit = entry.getKey().getProfit();
            Integer units = entry.getValue();
            Double profit = units * productProfit;
            totalDailyProfit += profit;
        }
        return totalDailyProfit;
    }
}

// Product class that stores product information: product name and profit generated by the product
// Read-only
class Product{
    String productName;
    double profit;

    // constructor and getter
    public Product(String productName,  double profit) {
        this.productName = productName;
        this.profit = profit;
    }
    public String getProductName() {
        return productName;
    }
    public double getProfit(){
        return profit;
    }

}

// SalesRecord records the daily sales of different products for a branch
// Consist of a hash map recording product object and corresponding units sold
// Read-only
class SalesRecord {
    HashMap<Product, Integer> unitsSold = new HashMap<>(); //map to store products and units sold

    //constructor and getter
    public SalesRecord(HashMap<Product, Integer> unitsSold) {
        this.unitsSold = unitsSold;
    }
    public HashMap<Product, Integer> getSalesRecord() {
        return unitsSold;
    }
}

// Records totalUnitsSold, totalDailyProfits and lowestProfitBranch across all branches
// Consist of a method that compares lowestProfitBranch
// Read and write
class GlobalSalesRecord{
    private HashMap<Product, Integer> totalUnitsSold = new HashMap<>();
    private double totalDailyProfits = 0;
    private Branch lowestProfitBranch;
    private Double lowestProfit = Double.MAX_VALUE;

    // constructor, setters and getters
    public GlobalSalesRecord(Product[] products){
        for(Product product: products){
            this.totalUnitsSold.put(product, 0);
        }
        this.totalUnitsSold = totalUnitsSold;
    }

    public synchronized HashMap<Product, Integer> getTotalUnitsSold(){
        return totalUnitsSold;
    }

    public synchronized void setTotalUnitsSold(Product product, Integer branchUnits){
        this.getTotalUnitsSold().put(product, branchUnits);
    }

    public synchronized double getTotalDailyProfits(){
        return totalDailyProfits;
    }

    public synchronized void setTotalDailyProfits(Double newTotal){
        this.totalDailyProfits = newTotal;
    }

    public synchronized Branch getLowestProfitBranch(){
        return lowestProfitBranch;
    }

    // compares lowest profit given a branch
    public synchronized void compareAndSetLowestProfit(Branch branch){
        if (branch.getDailyTotalProfit() < this.lowestProfit){
            this.lowestProfitBranch = branch;
            this.lowestProfit = branch.getDailyTotalProfit();
        }
    }

    public void printSalesReport() throws IOException {
        int[] unitsSold = new int[6];
        String[] productNames = {"A", "B", "C", "D", "E", "F"};

        for (Product product : totalUnitsSold.keySet()) {
            switch (product.getProductName()) {
                case "A":
                    unitsSold[0] = totalUnitsSold.get(product);
                    break;
                case "B":
                    unitsSold[1] = totalUnitsSold.get(product);
                    break;
                case "C":
                    unitsSold[2] = totalUnitsSold.get(product);
                    break;
                case "D":
                    unitsSold[3] = totalUnitsSold.get(product);
                    break;
                case "E":
                    unitsSold[4] = totalUnitsSold.get(product);
                    break;
                case "F":
                    unitsSold[5] = totalUnitsSold.get(product);
                    break;
            }
        }

        System.out.printf("%-20s%-20s%-20s%-20s%-20s%-20s%n", "Product A", "Product B", "Product C", "Product D", "Product E", "Product F");
        System.out.printf("%-20s%-20s%-20s%-20s%-20s%-20s%n", "(Total Units Sold)", "(Total Units Sold)", "(Total Units Sold)", "(Total Units Sold)", "(Total Units Sold)", "(Total Units Sold)");
        System.out.printf("%-20d%-20d%-20d%-20d%-20d%-20d%n", unitsSold[0], unitsSold[1], unitsSold[2], unitsSold[3], unitsSold[4], unitsSold[5]);
        System.out.println();
        System.out.printf("%-20s%-20s%n", "Total Daily Profits", "Branch with Lowest Profit");
        System.out.printf("%-20.1f%-20s%n", totalDailyProfits, lowestProfitBranch.getBranchID());
    }
}

// A class to read csv files into branches and sales record objects
class SalesRecordReader {
    public static List<Branch> readSalesRecords(String fileName, Product[] products) throws IOException {
        // keep track of available of branches
        List<Branch> branches = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            String line;
            String header = br.readLine();
            // skip first line and read the rest of the data
            while ((line = br.readLine()) != null) {
                String[] values = line.split(",");
                String branchID = values[0];
                // create sales record
                HashMap<Product, Integer> salesRecord = new HashMap<>();
                for (int i = 1; i <= 6; i++) {
                    salesRecord.put(products[i-1], Integer.parseInt(values[i]));
                }
                // create new branch object
                branches.add(new Branch(branchID, salesRecord));
            }
        }
        return branches;
    }
}

// A runnable interface that calculates total units sold across all branches
// Executed by one thread: executed for one product in one branch
class TotalUnitsSold implements Runnable {
    private Branch branch;
    private Product product;
    private GlobalSalesRecord globalSalesRecord;

    // constructor
    public TotalUnitsSold(Branch branch, Product product, GlobalSalesRecord globalSalesRecord) {
        this.branch = branch;
        this.product = product;
        this.globalSalesRecord = globalSalesRecord;
    }

    // runnable method
    public void run() {
        // get units sold of a product by current branch
        Integer unitsSold = this.branch.getSalesRecord().get(this.product);
        // synchronise globalSalesRecord, so only one thread can access globalSalesRecord's information at a time
        synchronized (globalSalesRecord) {
            // get latest total units sold for a product from global sales record
            Integer latestTotalUnitsSold = this.globalSalesRecord.getTotalUnitsSold().get(this.product);
            // update total global sales with units sold from current branch
            Integer newTotal = latestTotalUnitsSold + unitsSold;
            globalSalesRecord.setTotalUnitsSold(this.product, newTotal);
        }
    }
}

// A runnable interface that calculates total profits for all products across all branches
// Executed by one thread: executed for one branch
class TotalDailyProfit implements Runnable {
    private Branch branch;
    private Product product;
    private GlobalSalesRecord globalSalesRecord;

    // constructor
    public TotalDailyProfit(Branch branch, GlobalSalesRecord globalSalesRecord) {
        this.branch = branch;
        this.globalSalesRecord = globalSalesRecord;
    }

    // runnable method
    public void run() {
        // get latest total profit for all products by current branch
        Double branchProfit = this.branch.getDailyTotalProfit();
        // synchronise globalSalesRecord, so only one thread can read and write it at one time
        synchronized (globalSalesRecord) {
            // get latest total profits from globalSalesRecord
            Double latestTotalDailyProfit = this.globalSalesRecord.getTotalDailyProfits();
            // add and update total profits with profits of current branch
            globalSalesRecord.setTotalDailyProfits(latestTotalDailyProfit + branchProfit);
            globalSalesRecord.compareAndSetLowestProfit(branch);
        }
    }
}

// Driver class
public class Main {
    public static void main(String[] args) throws IOException, InterruptedException {
        // initialise available products
        Product[] products = new Product[]{new Product("A", 1.10),
                new Product("B", 1.50),
                new Product("C", 2.10),
                new Product("D", 1.60),
                new Product("E", 1.80),
                new Product("F", 3.90)};
        // read csv files into branch objects
        List<Branch> branches = SalesRecordReader.readSalesRecords("/Users/summerthan/Desktop/currents/concurrent programming/ConcurrentProgrammingAssignment/src/sales_records.csv", products);
        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()+1);
        // create GlobalSalesRecord object
        GlobalSalesRecord globalSalesRecord = new GlobalSalesRecord(products);

        for (Branch branch: branches){
            // perform total profit summing for all branches
            executor.submit(new TotalDailyProfit(branch, globalSalesRecord));
            for (Product product: products) {
                //perform total units sold for each product
                executor.submit(new TotalUnitsSold(branch, product, globalSalesRecord));
            }
        }
        // shutdown executor and wait until all threads finish running
        executor.shutdown();
        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        // generate and print report
        globalSalesRecord.printSalesReport();
    }
}

